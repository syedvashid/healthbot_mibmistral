version v10 letest 325 321 css 226 main.py code is same for v9 , v10
---------------------------------------------------------------------------------------------------------------------------------------------------
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict
from langchain_ollama import ChatOllama
from langchain.memory import ConversationBufferMemory
from langchain.prompts import (
    ChatPromptTemplate,
    HumanMessagePromptTemplate,
    SystemMessagePromptTemplate,
    PromptTemplate
)
from langchain.chains import LLMChain
import logging
from fastapi.responses import JSONResponse, StreamingResponse
from io import BytesIO
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph ,Spacer
from reportlab.lib.styles import getSampleStyleSheet,ParagraphStyle
import asyncio
from reportlab.lib.enums import TA_LEFT






# Setup
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

class ChatRequest(BaseModel):
    user_input: str
    conversation_history: List[Dict[str, str]] = []
    language: str  # New field for language support

class HistoryRequest(BaseModel):
    name: str
    gender: str
    age: int
    language: str  # New field for language
    conversation_history: List[Dict[str, str]]

class OfflineReportRequest(BaseModel):
    name: str
    age: int
    gender: str
    department: str
    language: str  # New field for language
    responses: List[Dict]

# Initialize Ollama
llm = ChatOllama(
    model="llama3",
    temperature=0.7,
    max_tokens=500,
    timeout=30
)

# System Prompts
MEDICAL_PROMPT = """You are a professional medical assistant.,Based on conversation history, and preferred language, generate exactly 5 multiple-choice questions (one at a time) to gather information about the patient’s condition and question must be  related to given disease.

Instructions:
- Each question must have **exactly 4 options** in new lines, labeled A, B, C, and D.
- Each option must include **EHR-specific terminology** in parentheses.
- The format for options should be: "A. Description (EHR Term)"
- Add a **new line** between each question and between each option for better readability.
- All questions and options must be in the selected language: {language}.
- after 5 questions end conversatio by  recommend consulting a doctor for further assistance and suggest for download the PDF report.

Conversation History:
{conversation_history}

Return only the formatted questions and options, followed by the final suggestion.
"""
DEPARTMENT_PROMPT = """Analyze this health conversation and suggest ONE most relevant medical department:
Cardiology, Neurology, General Medicine, Orthopedics, Dermatology, ENT, Psychiatry, Gynecology, Gastroenterology.

Conversation:
{conversation_history}

Return ONLY the department name."""
REPORT_PROMPT = """Generate a comprehensive and professional pre-medical consultation assessment report with structured formatting and clarity. The report should include the following sections:

**Questions and Responses**
- Include all questions asked during the consultation along with the response provided by the patient in {language}.
- Each question should be clearly listed with its text and the available options (A, B, C, D) displayed on separate lines in {language}.
- Highlight the selected option on its own line in **bold** for emphasis.
- Do not invent or assume any additional questions beyond those {conversation_history}.

**Patient Summary**
- Provide a concise summary of the patient's condition based on the selected responses {language}.
- Reference specific questions and options to justify the overview.
- Chief Complaint: {chief_complaint}.

**Clinical History**
{history}

**Assessment**
- Evaluate the symptoms described by the patient and identify any potential areas of concern.
- Ensure consistency between the analysis and the responses provided to the questions.

**Recommendations**
- Based on the selected responses, classify the case as **High Risk**, **Medium Risk**, or **Low Risk**.
- Justify the classification using system-defined rules.

**Formatting Guidelines**
- Add proper line spacing between sections to ensure readability.
- Use **bold headings** and properly indent the content under each heading.
- Maintain a professional tone and concise language appropriate for medical review.
"""
OFFLINE_REPORT_PROMPT = """ Based on the following patient details:
           
            - Age: {age}
            - Gender: {gender}
            - Problem: {department}
            - Responses: {responses}
            - Language: {language}
 - Generate text (questions and their options) must be in specific {language}. 
 Generate  5 questions to gather information about the patient's condition. Each question should have exactly 4 options in Language .
 Provide EHR-specific terminology in parentheses for each option. 
 Help with auto flagging rules for high risk cases. 
 Return the questions and options in JSON format.
        
Provide a concise yet professional summary for doctor review."""

@app.get("/")
async def root():
    return {"message": "Welcome to the Health Chatbot Backend API!"}

# Core Chat Endpoint

@app.post("/chat")
async def chat(request: ChatRequest):
    try:
        conv_history = "\n".join(
            f"{msg['role'].upper()}: {msg['content']}" 
            for msg in request.conversation_history
        )

        prompt = ChatPromptTemplate.from_messages([
            SystemMessagePromptTemplate.from_template(
                MEDICAL_PROMPT.format(
                    conversation_history=conv_history,
                    language=request.language  # Include the user's selected language
                )
            ),
            HumanMessagePromptTemplate.from_template("{user_input}"),
        ])
        
        chain = LLMChain(llm=llm, prompt=prompt)
        response = await chain.arun(user_input=request.user_input)
        
        return {"response": response.strip()}

    except Exception as e:
        logger.error(f"Chat error: {str(e)}")
        raise HTTPException(500, "Chat processing failed")
    
# Department Suggestion
@app.post("/suggest_department")
async def suggest_department(request: HistoryRequest):
    try:
        conv_history = "\n".join(
            f"{msg['role'].upper()}: {msg['content']}" 
            for msg in request.conversation_history
        )
        
        prompt = PromptTemplate(
            input_variables=["conversation_history"],
            template=DEPARTMENT_PROMPT
        )
        chain = LLMChain(llm=llm, prompt=prompt)
        department = await chain.arun(conversation_history=conv_history)
        return {"department": department.strip()}
    
    except Exception as e:
        logger.error(f"Department error: {str(e)}")
        return {"department": "General Medicine"}

# PDF Report Generation
@app.post("/generate_report")
async def generate_report(request: HistoryRequest):
    try:    
        # Extract name, gender, and age from the request
        name = request.name
        gender = request.gender
        age = request.age
        language = request.language  # New field for language support
        
        # Extract chief complaint
        chief_complaint = next(
            (msg["content"] for msg in request.conversation_history 
             if msg["role"] == "user"),
            "Not specified"
        )
        
        # Build conversation history
        conv_history = "\n".join(
            f"{msg['role'].upper()}: {msg['content']}" 
            for msg in request.conversation_history
        )

        # Prepare LangChain LLM call
        prompt = PromptTemplate(
            input_variables=["chief_complaint", "history", "conversation_history","language"],
            template=REPORT_PROMPT
        )
        chain = LLMChain(llm=llm, prompt=prompt)
        report_text = await chain.arun(
            chief_complaint=chief_complaint,
            history="From conversation",
            conversation_history=conv_history,
            language=language  # Include language in the prompt
        )

        # PDF Generation with styling
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=letter)

        # Styles
        base_styles = getSampleStyleSheet()
        heading_style = ParagraphStyle(
            'Heading',
            parent=base_styles['Heading2'],
            fontSize=14,
            spaceAfter=10,
            spaceBefore=12,
            leftIndent=0,
            alignment=TA_LEFT,
            fontName='Helvetica-Bold'
        )
        body_style = ParagraphStyle(
            'Body',
            parent=base_styles['Normal'],
            fontSize=11,
            leading=16,
            leftIndent=20
        )

        story = []

        # Title
        story.append(Paragraph("Medical Consultation Report", heading_style))
        story.append(Spacer(1, 12))

        # Patient Details Section
        story.append(Paragraph("Patient Details", heading_style))
        story.append(Spacer(1, 6))
        story.append(Paragraph(f"Name: {name}", body_style))
        story.append(Paragraph(f"Gender: {gender}", body_style))
        story.append(Paragraph(f"Age: {age}", body_style))
        story.append(Spacer(1, 12))

        # Split report into sections and format
        for paragraph in report_text.split('\n\n'):
            stripped = paragraph.strip()
            if not stripped:
                continue
            if stripped.endswith(":"):  # Assume it's a heading
                story.append(Spacer(1, 10))
                story.append(Paragraph(stripped, heading_style))
            else:
                story.append(Paragraph(stripped, body_style))
            story.append(Spacer(1, 6))

        doc.build(story)
        buffer.seek(0)

        return StreamingResponse(
            buffer,
            media_type="application/pdf",
            headers={"Content-Disposition": "attachment; filename=medical_report.pdf"}
        )

    except Exception as e:
        logger.error(f"Report error: {str(e)}")
        raise HTTPException(500, "Report generation failed")

# Offline Report Generation
@app.post("/generate_offline_report")
async def generate_offline_report(request: OfflineReportRequest):
    try:
        prompt = PromptTemplate(
            input_variables=["name", "age", "gender", "department", "language", "responses"],
            template=OFFLINE_REPORT_PROMPT
        )
        chain = LLMChain(llm=llm, prompt=prompt)
        report_content = await chain.arun(
            name=request.name,
            age=request.age,
            gender=request.gender,
            department=request.department,
            language=request.language,  # Include language in the prompt
            responses=request.responses,
        )

        report = {
            "Patient Details": {
                "Name": request.name,
                "Age": request.age,
                "Gender": request.gender,
                "Department": request.department,
                "Language": request.language,  # Include language in the JSON response
            },
            "Report": report_content,
            "Remarks": "This is an auto-generated offline medical  with language consideration.",
        }

        return JSONResponse(
            content=report,
            headers={"Content-Disposition": "attachment; filename=offline_report.json"}
        )
    except Exception as e:
        logger.error(f"Error in /generate_offline_report endpoint: {str(e)}")
        raise HTTPException(500, "Offline report generation failed")



























import React, { useState, useRef, useEffect } from 'react';
import './App.css';
import formImage from './img.png';

function App() {
  const [step, setStep] = useState('form'); // 'form' or 'chatbot'
  const [formData, setFormData] = useState({
    name: '',
    age: '',
    gender: 'Male',
    department: 'General Medicine',
    language: 'English', // New field for language
  });
  const [input, setInput] = useState('');
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [suggestedDepartment, setSuggestedDepartment] = useState(''); // State for suggested department
  const messagesEndRef = useRef(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    if (step === 'chatbot') scrollToBottom();
  }, [messages, step]);

  const handleFormSubmit = () => {
    if (!formData.name || !formData.age || !formData.department || !formData.language) { // Validate language
      alert('Please fill all the fields before proceeding.');
      return;
    }
    setStep('chatbot');
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!input.trim()) return;

    const userMessage = { role: 'user', content: input };
    setMessages((prev) => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const response = await fetch('http://localhost:8000/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          user_input: input,
          conversation_history: messages, // Pass the entire conversation history
          language: formData.language,    // Added field
        }),
      });

      const data = await response.json();
      setMessages((prev) => [...prev, { role: 'assistant', content: data.response }]);
    } catch (error) {
      console.error('Error:', error);
      setMessages((prev) => [
        ...prev,
        { role: 'assistant', content: 'Sorry, I encountered an error. Please try again.' },
      ]);
    } finally {
      setIsLoading(false);
    }
  };

  const generateReport = async () => {
    if (messages.length === 0) {
      alert('Please have a conversation before generating a report.');
      return;
    }

    setIsLoading(true);
    try {
      const response = await fetch('http://localhost:8000/generate_report', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: formData.name,        // Include name
          gender: formData.gender,    // Include gender
          age: formData.age,          // Include age
          language: formData.language, // Include language
          conversation_history: messages,
        }),
      });

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'medical_report.pdf';
      document.body.appendChild(a);
      a.click();
      a.remove();
    } catch (error) {
      console.error('Report error:', error);
      alert('Failed to generate report');
    } finally {
      setIsLoading(false);
    }
  };

  const generateOfflineReport = async () => {
    if (!formData.name || !formData.age || !formData.department || !formData.language) { // Validate language
      alert('Please fill all the fields before generating the offline report.');
      return;
    }

    // Simulate responses for the assessment questions
    const responses = [
      { questionId: 1, option: 'A' },
      { questionId: 2, option: 'C' },
      { questionId: 3, option: 'B' },
      { questionId: 4, option: 'D' },
      { questionId: 5, option: 'A' },
    ];

    setIsLoading(true);
    try {
      const response = await fetch('http://localhost:8000/generate_offline_report', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: formData.name,
          age: formData.age,
          gender: formData.gender,
          department: formData.department,
          language: formData.language, // Include language in the request
          responses: responses,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to generate offline report.');
      }

      const data = await response.json();
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'offline_report.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
    } catch (error) {
      console.error('Offline Report Error:', error);
      alert('Failed to generate offline report.');
    } finally {
      setIsLoading(false);
    }
  };

  const suggestDepartment = async () => {
    if (messages.length === 0) {
      alert('Please have a conversation before suggesting a department.');
      return;
    }

    setIsLoading(true);
    try {
      const response = await fetch('http://localhost:8000/suggest_department', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          conversation_history: messages,
        }),
      });

      const data = await response.json();
      setSuggestedDepartment(data.department || 'General Medicine');
      alert(`Suggested Department: ${data.department || 'General Medicine'}`);
    } catch (error) {
      console.error('Error suggesting department:', error);
      alert('Failed to suggest department.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="app">
      <header className="header">
        <h1>Medical Chatbot</h1>
      </header>
      {step === 'form' ? (
        <div className="form-container">
          <img src={formImage} alt="Medical Illustration" className="form-image" />
          <div>
            <h2>Enter Your Details</h2>
            <form>
              <label>
                Name:
                <input
                  type="text"
                  value={formData.name}
                  onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                />
              </label>
              <label>
                Age:
                <input
                  type="number"
                  value={formData.age}
                  onChange={(e) => setFormData({ ...formData, age: e.target.value })}
                />
              </label>
              <label>
                Gender:
                <select
                  value={formData.gender}
                  onChange={(e) => setFormData({ ...formData, gender: e.target.value })}
                >
                  <option value="Male">Male</option>
                  <option value="Female">Female</option>
                  <option value="Other">Other</option>
                </select>
              </label>
              <label>
                Problem:
                <input
                  type="text"
                  value={formData.department}
                  onChange={(e) => setFormData({ ...formData, department: e.target.value })}
                />
              </label>
              <label>
                Language:
                <select
                  value={formData.language}
                  onChange={(e) => setFormData({ ...formData, language: e.target.value })}
                >
                  <option value="English">English</option>
                  <option value="Hindi">हिंदी</option>
                  <option value="Telugu">తెలుగు</option>
                </select>
              </label>
              <div className="form-buttons">
                <button type="button" onClick={handleFormSubmit}>
                  Open Chatbot
                </button>
                <button type="button" onClick={generateOfflineReport}>
                  Offline Report
                </button>
              </div>
            </form>
          </div>
        </div>
      ) : (
        <div className="chat-container">
          <div className="chat-box">
            <div className="messages">
              {messages.length === 0 ? (
                <div className="welcome-message">
                  <p>Describe your symptoms...</p>
                </div>
              ) : (
                messages.map((msg, index) => (
                  <div key={index} className={`message ${msg.role}`}>
                    {msg.content}
                  </div>
                ))
              )}
              <div ref={messagesEndRef} />
              {isLoading && <div className="message assistant typing">Typing...</div>}
            </div>

            <form onSubmit={handleSubmit} className="input-area">
              <input
                type="text"
                value={input}
                onChange={(e) => setInput(e.target.value)}
                placeholder="Type your symptoms..."
                disabled={isLoading}
              />
              <button type="submit" disabled={isLoading}>
                Send
              </button>
            </form>

            <div className="report-container">
              <button
                onClick={generateReport}
                disabled={isLoading || messages.length === 0}
                className="report-btn"
              >
                Generate PDF Report
              </button>
              <button
                onClick={suggestDepartment}
                disabled={isLoading || messages.length === 0}
                className="report-btn"
              >
                Suggest Department
              </button>
            </div>

            {suggestedDepartment && (
              <div className="suggested-department">
                <p>Suggested Department: {suggestedDepartment}</p>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}

export default App;
















v10  226 -----------------
/* Updated Colors */
:root {
  --primary-blue: #762e8d;
  --secondary-light: #f8f9fa;
  --accent-green: #28a745;
  --dark-text: #343a40;
  --light-text: #6c757d;
  --border-color: #ced4da; /* A more standard border color */
  --background-light: #ffffff; /* Assuming a white background */
  --button-purple: #8e44ad; /* Purple color for buttons */
 }
 
 .app {
  max-width: 1200px; /* Wider to feel more like a website */
  margin: 2rem auto; /* Add more top/bottom margin for spacing */
  padding: 2rem; /* Increase padding */
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* A more modern and common web font */
  background-color: var(--background-light); /* Use the background color variable */
  border-radius: 8px; /* Optional: Add a subtle rounded border */
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); /* Optional: Subtle shadow */
 }
 
 .header {
  text-align: left; /* Align header text to the left, common on websites */
  margin-bottom: 2.5rem; /* Increase bottom margin */
  padding-bottom: 1.5rem;
  border-bottom: 1px solid var(--border-color); /* Add a subtle bottom border */
 }
 
 .header h1 {
  color: var(--primary-blue); /* Use the primary blue color */
  font-size: 2.5rem; /* Slightly larger font size */
  margin-bottom: 0.5rem;
 }
 
 .chat-container {
  display: flex;
  justify-content: center; /* Keep this if you want the chat centered */
 }


 .chat-box {
  width: 100%;
  max-width: 900px; /* Limit the width of the chat box */
  display: flex;
  flex-direction: column;
 }
 
 .messages {
  flex: 1;
  overflow-y: auto;
  padding: 1.2rem; /* Increase padding */
  margin-bottom: 1.2rem;
  border: 1px solid var(--border-color); /* Use the border color variable */
  border-radius: 8px;
  background-color: var(--secondary-light); /* Use the light background color */
  min-height: 400px;
  max-height: 600px; /* Adjust max height if needed */
 }
 
 .message {
  margin-bottom: 1rem; /* Increase margin */
  padding: 1rem; /* Increase padding */
  border-radius: 10px; /* More rounded message bubbles */
  max-width: 70%; /* Slightly reduce max width for visual appeal */
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05); /* Subtle shadow for messages */
 }
 
 .message.user {
  background-color: #e7f5ff; /* Lighter blue for user messages */
  margin-left: auto;
  color: var(--dark-text); /* Darker text for better readability */
 }
 
 .message.assistant {
  background-color: #f8f9fa; /* Light gray for assistant messages */
  margin-right: auto;
  color: var(--dark-text);
 }
 
 .message.typing {
  background-color: #f8f9fa;
  color: var(--light-text); /* Use the light text color */
  font-style: italic;
 }
 
 .welcome-message {
  text-align: center;
  color: var(--light-text); /* Use the light text color */
  font-style: italic;
  margin-bottom: 2rem; /* Add some space below */
 }
 
 .input-area {
  display: flex;
  gap: 0.8rem; /* Increase gap */
  margin-top: 1.5rem; /* Increase margin */
  margin-bottom: 1.5rem; /* Increase margin */
  padding: 0 1rem; /* Add some horizontal padding */
 }
 
 .input-area input {
  flex: 1;
  padding: 1rem; /* Increase padding */
  border: 1px solid var(--border-color); /* Use the border color variable */
  border-radius: 6px; /* Slightly more rounded input */
  font-size: 1.1rem; /* Slightly larger font size */
 }
 
 .input-area button {
  padding: 1rem 2rem; /* Increase padding */
  background-color: var(--button-purple); /* Use purple color */
  color: white;
  border: none;
  border-radius: 6px; /* Slightly more rounded button */
  cursor: pointer;
  font-size: 1.1rem; /* Slightly larger font size */
  transition: background-color 0.3s ease; /* Add a smooth transition for hover effect */
 }
 
 .input-area button:hover {
  background-color: #762e8d; /* Darker shade on hover */
 }
 
 .input-area button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
 }
 
 .report-container {
  display: flex;
  justify-content: center;
  margin-top: 2rem; /* Increase margin */
 }
 
 .report-btn {
  padding: 1rem 2rem; /* Increase padding */
  background-color: var(--button-purple); /* Use purple color */
  color: white;
  border: none;
  border-radius: 6px; /* Slightly more rounded button */
  cursor: pointer;
  font-size: 1.1rem; /* Slightly larger font size */
  font-weight: bold;
  transition: background-color 0.3s ease; /* Add a smooth transition for hover effect */
 }
 
 .report-btn:hover {
  background-color: #762e8d; /* Darker shade on hover */
 }
 
 .report-btn:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
 }
 
 
.form-container {
  display: flex;
  align-items: center; /* Vertically align image and form */
  gap: 30px; /* Space between image and form */
  flex-direction: row; /* Ensure image and form are in a row */
}

.form-container h2 {
  margin-top: 0;
  margin-bottom: 15px;
}
 
.form-container form {
  display: flex;
  flex-direction: column;
  width: 300px;
  padding: 20px;
  border: 1px solid #ccc;
  border-radius: 5px;
  background-color: #f9f9f9;
}

.form-container label {
  margin-bottom: 10px;
  display: flex;
  flex-direction: column;
}
 
 .form-container input,
 .form-container select {
  padding: 8px;
  margin-top: 5px;
  border: 1px solid #ddd;
  border-radius: 3px
 }
 
 
.form-container .form-buttons {
  margin-top: 20px;
  display: flex;
  gap: 10px;
}

.form-container button {
  padding: 10px 15px;
  border: none;
  border-radius: 5px;
  background-color: #762e8d;
  color: white;
  cursor: pointer;
  transition: background-color 0.3s ease; /* Add a smooth transition for hover effect */
}
 
 .form-buttons button:hover {
  background-color: #762e8d; /* Darker shade on hover */
 }
 
 .form-buttons button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
 }
 
 .suggested-department {
  margin-top: 6rem; /* Increase margin */
  text-align: center;
  font-size: 1.3rem; /* Slightly larger font size */
  color: var(--accent-green); /* Use the accent green color */
  font-weight: bold;
 }
 


 ----------------------------------v9 old without image----------------------------------------------------------------------------

 317,223




 import React, { useState, useRef, useEffect } from 'react';
import './App.css';

function App() {
  const [step, setStep] = useState('form'); // 'form' or 'chatbot'
  const [formData, setFormData] = useState({
    name: '',
    age: '',
    gender: 'Male',
    department: 'General Medicine',
    language: 'English', // New field for language
  });
  const [input, setInput] = useState('');
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [suggestedDepartment, setSuggestedDepartment] = useState(''); // State for suggested department
  const messagesEndRef = useRef(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    if (step === 'chatbot') scrollToBottom();
  }, [messages, step]);

  const handleFormSubmit = () => {
    if (!formData.name || !formData.age || !formData.department || !formData.language) { // Validate language
      alert('Please fill all the fields before proceeding.');
      return;
    }
    setStep('chatbot');
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!input.trim()) return;

    const userMessage = { role: 'user', content: input };
    setMessages((prev) => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const response = await fetch('http://localhost:8000/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          user_input: input,
          conversation_history: messages, // Pass the entire conversation history
          language: formData.language,    // Added field
        }),
      });

      const data = await response.json();
      setMessages((prev) => [...prev, { role: 'assistant', content: data.response }]);
    } catch (error) {
      console.error('Error:', error);
      setMessages((prev) => [
        ...prev,
        { role: 'assistant', content: 'Sorry, I encountered an error. Please try again.' },
      ]);
    } finally {
      setIsLoading(false);
    }
  };

  const generateReport = async () => {
    if (messages.length === 0) {
      alert('Please have a conversation before generating a report.');
      return;
    }

    setIsLoading(true);
    try {
      const response = await fetch('http://localhost:8000/generate_report', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: formData.name,        // Include name
          gender: formData.gender,    // Include gender
          age: formData.age,          // Include age
          language: formData.language, // Include language
          conversation_history: messages,
        }),
      });

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'medical_report.pdf';
      document.body.appendChild(a);
      a.click();
      a.remove();
    } catch (error) {
      console.error('Report error:', error);
      alert('Failed to generate report');
    } finally {
      setIsLoading(false);
    }
  };

  const generateOfflineReport = async () => {
    if (!formData.name || !formData.age || !formData.department || !formData.language) { // Validate language
      alert('Please fill all the fields before generating the offline report.');
      return;
    }

    // Simulate responses for the assessment questions
    const responses = [
      { questionId: 1, option: 'A' },
      { questionId: 2, option: 'C' },
      { questionId: 3, option: 'B' },
      { questionId: 4, option: 'D' },
      { questionId: 5, option: 'A' },
    ];

    setIsLoading(true);
    try {
      const response = await fetch('http://localhost:8000/generate_offline_report', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: formData.name,
          age: formData.age,
          gender: formData.gender,
          department: formData.department,
          language: formData.language, // Include language in the request
          responses: responses,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to generate offline report.');
      }

      const data = await response.json();
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'offline_report.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
    } catch (error) {
      console.error('Offline Report Error:', error);
      alert('Failed to generate offline report.');
    } finally {
      setIsLoading(false);
    }
  };

  const suggestDepartment = async () => {
    if (messages.length === 0) {
      alert('Please have a conversation before suggesting a department.');
      return;
    }

    setIsLoading(true);
    try {
      const response = await fetch('http://localhost:8000/suggest_department', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          conversation_history: messages,
        }),
      });

      const data = await response.json();
      setSuggestedDepartment(data.department || 'General Medicine');
      alert(`Suggested Department: ${data.department || 'General Medicine'}`);
    } catch (error) {
      console.error('Error suggesting department:', error);
      alert('Failed to suggest department.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="app">
      <header className="header">
        <h1>Medical Chatbot</h1>
      </header>
      {step === 'form' ? (
        <div className="form-container">
          <h2>Enter Your Details</h2>
          <form>
            <label>
              Name:
              <input
                type="text"
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
              />
            </label>
            <label>
              Age:
              <input
                type="number"
                value={formData.age}
                onChange={(e) => setFormData({ ...formData, age: e.target.value })}
              />
            </label>
            <label>
              Gender:
              <select
                value={formData.gender}
                onChange={(e) => setFormData({ ...formData, gender: e.target.value })}
              >
                <option value="Male">Male</option>
                <option value="Female">Female</option>
                <option value="Other">Other</option>
              </select>
            </label>
            <label>
              Problem:
              <input
                type="text"
                value={formData.department}
                onChange={(e) => setFormData({ ...formData, department: e.target.value })}
              />
            </label>
            <label>
              Language:
              <select
                value={formData.language}
                onChange={(e) => setFormData({ ...formData, language: e.target.value })}
              >
                <option value="English">English</option>
                <option value="Hindi">हिंदी</option>
                <option value="Telugu">తెలుగు</option>
              </select>
            </label>
            <div className="form-buttons">
              <button type="button" onClick={handleFormSubmit}>
                Open Chatbot
              </button>
              <button type="button" onClick={generateOfflineReport}>
                Offline Report
              </button>
            </div>
          </form>
        </div>
      ) : (
        <div className="chat-container">
          <div className="chat-box">
            <div className="messages">
              {messages.length === 0 ? (
                <div className="welcome-message">
                  <p>Describe your symptoms...</p>
                </div>
              ) : (
                messages.map((msg, index) => (
                  <div key={index} className={`message ${msg.role}`}>
                    {msg.content}
                  </div>
                ))
              )}
              <div ref={messagesEndRef} />
              {isLoading && <div className="message assistant typing">Typing...</div>}
            </div>

            <form onSubmit={handleSubmit} className="input-area">
              <input
                type="text"
                value={input}
                onChange={(e) => setInput(e.target.value)}
                placeholder="Type your symptoms..."
                disabled={isLoading}
              />
              <button type="submit" disabled={isLoading}>
                Send
              </button>
            </form>

            <div className="report-container">
              <button
                onClick={generateReport}
                disabled={isLoading || messages.length === 0}
                className="report-btn"
              >
                Generate PDF Report
              </button>
              <button
                onClick={suggestDepartment}
                disabled={isLoading || messages.length === 0}
                className="report-btn"
              >
                Suggest Department
              </button>
            </div>

            {suggestedDepartment && (
              <div className="suggested-department">
                <p>Suggested Department: {suggestedDepartment}</p>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}

export default App;














/* Updated Colors */
:root {
  --primary-blue: #007bff;
  --secondary-light: #f8f9fa;
  --accent-green: #28a745;
  --dark-text: #343a40;
  --light-text: #6c757d;
  --border-color: #ced4da; /* A more standard border color */
  --background-light: #ffffff; /* Assuming a white background */
  --button-purple: #8e44ad; /* Purple color for buttons */
 }
 
 .app {
  max-width: 1200px; /* Wider to feel more like a website */
  margin: 2rem auto; /* Add more top/bottom margin for spacing */
  padding: 2rem; /* Increase padding */
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* A more modern and common web font */
  background-color: var(--background-light); /* Use the background color variable */
  border-radius: 8px; /* Optional: Add a subtle rounded border */
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); /* Optional: Subtle shadow */
 }
 
 .header {
  text-align: left; /* Align header text to the left, common on websites */
  margin-bottom: 2.5rem; /* Increase bottom margin */
  padding-bottom: 1.5rem;
  border-bottom: 1px solid var(--border-color); /* Add a subtle bottom border */
 }
 
 .header h1 {
  color: var(--primary-blue); /* Use the primary blue color */
  font-size: 2.5rem; /* Slightly larger font size */
  margin-bottom: 0.5rem;
 }
 
 .chat-container {
  display: flex;
  justify-content: center; /* Keep this if you want the chat centered */
 }
 
 .chat-box {
  width: 100%;
  max-width: 900px; /* Limit the width of the chat box */
  display: flex;
  flex-direction: column;
 }
 
 .messages {
  flex: 1;
  overflow-y: auto;
  padding: 1.2rem; /* Increase padding */
  margin-bottom: 1.2rem;
  border: 1px solid var(--border-color); /* Use the border color variable */
  border-radius: 8px;
  background-color: var(--secondary-light); /* Use the light background color */
  min-height: 400px;
  max-height: 600px; /* Adjust max height if needed */
 }
 
 .message {
  margin-bottom: 1rem; /* Increase margin */
  padding: 1rem; /* Increase padding */
  border-radius: 10px; /* More rounded message bubbles */
  max-width: 70%; /* Slightly reduce max width for visual appeal */
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05); /* Subtle shadow for messages */
 }
 
 .message.user {
  background-color: #e7f5ff; /* Lighter blue for user messages */
  margin-left: auto;
  color: var(--dark-text); /* Darker text for better readability */
 }
 
 .message.assistant {
  background-color: #f8f9fa; /* Light gray for assistant messages */
  margin-right: auto;
  color: var(--dark-text);
 }
 
 .message.typing {
  background-color: #f8f9fa;
  color: var(--light-text); /* Use the light text color */
  font-style: italic;
 }
 
 .welcome-message {
  text-align: center;
  color: var(--light-text); /* Use the light text color */
  font-style: italic;
  margin-bottom: 2rem; /* Add some space below */
 }
 
 .input-area {
  display: flex;
  gap: 0.8rem; /* Increase gap */
  margin-top: 1.5rem; /* Increase margin */
  margin-bottom: 1.5rem; /* Increase margin */
  padding: 0 1rem; /* Add some horizontal padding */
 }
 
 .input-area input {
  flex: 1;
  padding: 1rem; /* Increase padding */
  border: 1px solid var(--border-color); /* Use the border color variable */
  border-radius: 6px; /* Slightly more rounded input */
  font-size: 1.1rem; /* Slightly larger font size */
 }
 
 .input-area button {
  padding: 1rem 2rem; /* Increase padding */
  background-color: var(--button-purple); /* Use purple color */
  color: white;
  border: none;
  border-radius: 6px; /* Slightly more rounded button */
  cursor: pointer;
  font-size: 1.1rem; /* Slightly larger font size */
  transition: background-color 0.3s ease; /* Add a smooth transition for hover effect */
 }
 
 .input-area button:hover {
  background-color: #762e8d; /* Darker shade on hover */
 }
 
 .input-area button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
 }
 
 .report-container {
  display: flex;
  justify-content: center;
  margin-top: 2rem; /* Increase margin */
 }
 
 .report-btn {
  padding: 1rem 2rem; /* Increase padding */
  background-color: var(--button-purple); /* Use purple color */
  color: white;
  border: none;
  border-radius: 6px; /* Slightly more rounded button */
  cursor: pointer;
  font-size: 1.1rem; /* Slightly larger font size */
  font-weight: bold;
  transition: background-color 0.3s ease; /* Add a smooth transition for hover effect */
 }
 
 .report-btn:hover {
  background-color: #762e8d; /* Darker shade on hover */
 }
 
 .report-btn:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
 }
 
 .form-container {
  max-width: 500px; /* Slightly wider form */
  margin: 2rem auto; /* Increase margin */
  padding: 1.5rem; /* Increase padding */
  border: 1px solid var(--border-color); /* Use the border color variable */
  border-radius: 8px;
  background-color: var(--secondary-light); /* Use the light background color */
 }
 
 .form-container h2 {
  text-align: center;
  color: var(--dark-text); /* Use the dark text color */
  margin-bottom: 1.5rem; /* Increase bottom margin */
 }
 
 .form-container label {
  display: block;
  margin-bottom: 0.6rem; /* Adjust margin */
  color: var(--light-text); /* Use the light text color */
  font-weight: bold; /* Make labels slightly bolder */
 }
 
 .form-container input,
 .form-container select {
  width: 100%;
  padding: 0.9rem; /* Increase padding */
  margin-top: 0.4rem; /* Adjust margin */
  margin-bottom: 1.2rem; /* Increase margin */
  border: 1px solid var(--border-color); /* Use the border color variable */
  border-radius: 6px; /* Slightly more rounded input/select */
  font-size: 1.1rem; /* Slightly larger font size */
 }
 
 .form-buttons {
  display: flex;
  justify-content: flex-end; /* Align buttons to the right, common in forms */
  gap: 0.8rem; /* Add gap between buttons */
  margin-top: 1.5rem; /* Add top margin */
 }
 
 .form-buttons button {
  padding: 1rem 2rem; /* Increase padding */
  background-color: var(--button-purple); /* Use purple color */
  color: white;
  border: none;
  border-radius: 6px; /* Slightly more rounded buttons */
  cursor: pointer;
  font-size: 1.1rem; /* Slightly larger font size */
  transition: background-color 0.3s ease; /* Add a smooth transition for hover effect */
 }
 
 .form-buttons button:hover {
  background-color: #762e8d; /* Darker shade on hover */
 }
 
 .form-buttons button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
 }
 
 .suggested-department {
  margin-top: 6rem; /* Increase margin */
  text-align: center;
  font-size: 1.3rem; /* Slightly larger font size */
  color: var(--accent-green); /* Use the accent green color */
  font-weight: bold;
 }
 